import abc
from typing import TYPE_CHECKING, List, Iterable

import numpy as np

from ModularChess.utils.BasicMovement import BasicMovement

if TYPE_CHECKING:
    from ModularChess.utils.Movement import Movement
    from ModularChess.controller.Board import Board
    from ModularChess.controller.Player import Player
    from ModularChess.utils.Position import Position


# TODO: Abstract classes or variable for Special movement
class Piece(metaclass=abc.ABCMeta):

    def __init__(self, board: "Board", player: "Player", starting_position: "Position"):
        self.player = player
        self.board = board
        self.position = starting_position  # TODO: Change to Optional

        self.n_moves = 0

    def __eq__(self, other) -> bool:
        if not isinstance(other, Piece):
            return False
        return self.player == other.player and self.board == other.board and \
            np.array_equal(self.position, other.position) and self.n_moves == other.n_moves

    @abc.abstractmethod
    def check_move(self, new_position: "Position") -> List["Movement"]:
        """
        Checks if the piece can be moved to the specified position. The moves to be tested should represent
        BasicMovement, allowing the testing through Movement.

        :param new_position: destination of the piece
        :return: List of valid movements that can accomplished going into the new_position
        """
        if np.array_equal(self.position, new_position) or self.board.is_position_outside(new_position):
            return []
        return [BasicMovement(self, new_position)]

    @abc.abstractmethod
    def get_valid_moves(self) -> List["Movement"]:
        # TODO: Filter moves that leave king in check
        pass

    def __can_move_to__(self, positions: Iterable["Position"]) -> Iterable["Position"]:
        """
        Auxiliary method to filter positions generated by `~utils.Position.Position.create_lineal_path`, so path doesn't
        continue after finding a piece to capture.

        :param positions: Positions in the lineal path to check
        :return:
        """
        # TODO: Improve

        for position in positions:
            if self.board.is_position_outside(position):
                return
            destination = self.board[position]
            if destination is None:
                yield position
            elif self.player.can_capture(destination.player):
                yield position
                return
            else:
                return

    @abc.abstractmethod
    def abbreviation(self) -> str:
        pass
