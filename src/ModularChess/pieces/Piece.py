import abc
import os
from typing import TYPE_CHECKING, List, Iterable, TextIO

import numpy as np

from ModularChess.movements.BasicMovement import BasicMovement

if TYPE_CHECKING:
    from ModularChess.movements.Movement import Movement
    from ModularChess.controller.Board import Board
    from ModularChess.controller.Player import Player
    from ModularChess.utils.Position import Position


class Piece(metaclass=abc.ABCMeta):
    res_path = os.path.join("..", "..", "res")

    def __init__(self, board: "Board", player: "Player", starting_position: "Position"):
        self.player = player
        self.board = board
        self.position = starting_position  # TODO: Change to Optional

        self.n_moves = 0

    def __eq__(self, other) -> bool:
        if not isinstance(other, Piece):
            return False
        return self.player == other.player and self.board == other.board and (
                np.array_equal(self.position, other.position) and self.n_moves == other.n_moves)

    def __hash__(self):
        return hash((self.__class__.__name__, self.player, self.n_moves))

    @abc.abstractmethod
    def check_piece_valid_move(self, new_position: "Position") -> List["Movement"]:
        """
        Checks if the piece can be moved to the specified position. The moves to be tested should represent
        BasicMovement, allowing the testing through Movement.

        :param new_position: destination of the piece
        :return: List of valid movements that can accomplished going into the new_position
        """
        if np.array_equal(self.position, new_position) or self.board.is_position_outside(new_position):
            return []
        return [BasicMovement(self, new_position)]

    @abc.abstractmethod
    def get_piece_valid_moves(self) -> List["Movement"]:
        pass

    def __can_move_to__(self, positions: Iterable["Position"]) -> Iterable["Position"]:
        """
        Auxiliary method to filter positions generated by `~utils.Position.Position.create_lineal_path`, so path doesn't
        continue after finding a piece to capture.

        :param positions: Positions in the lineal path to check
        :return:
        """
        # TODO: Improve

        for position in positions:
            if self.board.is_position_outside(position):
                return
            destination = self.board[position]
            if destination is None:
                yield position
            elif self.player.can_capture(destination.player):
                yield position
                return
            else:
                return

    @staticmethod
    @abc.abstractmethod
    def abbreviation() -> str:
        pass

    @staticmethod
    @abc.abstractmethod
    def piece_unicode() -> str:
        pass

    @staticmethod
    @abc.abstractmethod
    def image() -> TextIO:
        pass

    @staticmethod
    @abc.abstractmethod
    def piece_value() -> float:
        pass

    def __repr__(self) -> str:
        return self.piece_unicode()
